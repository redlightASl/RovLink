# 协议定义 Protocol Defination

本文档介绍了RovLink的消息帧结构、路由方式、通讯方式定义。

RovLink本质上是一种消息结构，可以建立在不同总线/传输协议物理层上。RovLink主要针对水下机器人的上位机（CoralReef-X）和下位机（FinNAV based ROV/AUV/UUV）通讯场景设计。

为了方便不同性能的设备使用，RovLink采用了**定长**帧结构，并设计了两种基本帧格式。

针对本文档中的内容，读者可以自行参考附录Excel中的表格和图示

## RovLink帧结构

一条RovLink消息被称为**RovLink帧**（**Frame**）

RovLink帧可以分成两种：

* **标准帧** `StandardDataFrame`：**上位机和机器人主控之间必须使用标准帧传输**，机器人内部可以选择传输标准帧或内部帧
* **内部帧** `InnerDataFrame`：**机器人内部使用CAN总线互联时，只能使用内部帧**，其他情况下，可选使用标准帧

特别地，RovLink支持以**突发**（**Burst**）的方式传输更大的数据

### 标准帧结构定义

一个RovLink标准帧包含10个字节的数据。

| 帧头起始位 | 数据类型 | 特征指示                    | 数据    | 帧尾校验位 |
| ---------- | -------- | --------------------------- | ------- | ---------- |
| FrameHead  | Opcode   | Ibits-DLC-Vbit-Sbit（IDVS） | Payload | Check      |

其中帧头**FrameHead**恒为一个字节（8 bit即1 Byte）的起始位`0xFD`

数据类型**Opcode**由一个对照表指定，对照表中每个不同的值都代表了一个不同的数据类型，本段也是8位

特征指示**IDVS**由四个不同的段构成，如下表所示

| 设备ID            | 数据长度码              | 检验有效位    | 传感器有效位   |
| ----------------- | ----------------------- | ------------- | -------------- |
| Identify（Ibits） | Data Length Code（DLC） | Valid（Vbit） | Sensor（Sbit） |

设备ID即Identify，简写为**Ibits**或**ID**，用来指示发送本帧的源设备（Source Device），中间设备（Route Device）根据本段进行数据路由。Ibits长度为4位（4 bits），可供使用的路由地址从0x0到0xF共16个，因此RovLink可以提供15个设备的路由

数据长度码Data Length Code，简写为**DLC**，用来指示本帧数据应当如何解算，根据不同取值可以分为如下四种情况：

* `2'b00`：多个数据，后续的数据Payload部分存储了6个uint8_t格式的数据

    > 常用于上位机控制下位机进行模式切换，或控制一些以开关量（0/1）描述的外设，也可用于上传较多具有小数值的传感器数据

* `2'b01`：大数或突发模式，后续的数据Payload部分存储了1个uint32_t格式的数据；或存储了1个uint48_t格式的数据；或存储了突发模式标志用来控制RovLink突发传输

    > 常用于突发传输的控制，详见后续RovLink突发传输部分；也用于某些特殊大数据的传输

* `2'b10`：2个数据，后续的数据Payload部分存储了1个uint32_t格式的数据和一个uint16_t格式的数据

    > 常用于对下位机某些算法关键参数的修改，uint32_t格式数据常常以32位浮点数（float）的方式被读取，后续的uint16_t则用于指定要修改算法的哪一个参数。特别地，*RovLink心跳包*采用这种DLC

* `2'b11`：3个数据，后续的数据Payload部分存储了3个uint16_t格式的数据

    > 常用于一般得外设控制和传感器数据上传

检验有效位Valid，简写为**Vbit**，长度为一个位（1 bit），用来控制本帧是否使用帧尾校验位。如果该位为1'b0，那么帧尾校验位会被忽略；如果该位为1'b1，那么需要使用程序预设的校验算法对数据Payload部分进行校验，并与帧尾校验位进行对比，如果不一致则舍弃该帧数据

传感器有效位Sensor，简写为**Sbit**，长度为一个位（1 bit）。在用于传输传感器数据的帧中，该位表示当前传感器的工作状态，用户程序可以自行选择是否相信本帧数据；而在其他功能的帧中，该位保留，用户被允许自行定义该位的用途

数据**Payload**包含6个字节（6 Bytes），用于搭载帧要传递的数据或指令。这些数据使用下面的几种数据格式被保存到帧中：

* *uint8_t*：数据被以8位无符号整型的方式存储
* *uint16_t*：数据被以16位无符号整型的方式存储
* *uint32_t*：数据被以32位无符号整型的方式存储
* *uint48_t*：数据被以48位无符号整型的方式存储

一般地，float_t格式的数据会被以32位无符号整型的方式直接保存到帧中进行传输，读取时再以float_t的形式进行读取，从而保证传输中的无精度损失；uint64_t或int64_t的数据会被直接放缩到符合uint48_t的数据格式大小后再以uint48_t的数据格式保存到帧中传输

在每帧中，一共6个字节的Payload以*大端*格式传输和存储

RovLink不支持double_t格式的数据传输

> 允许使用自定义的突发传输来逐帧传递48位以上长度的数据

帧尾**Check**是一个字节大小的校验位。如果IDVS中Sbit=0，那么该位在传输过程中可以被忽略；如果IDVS中Sbit=1，该位指定了以某一校验算法对Payload段进行校验计算后的输出值，每一个中间设备都需要进行一次校验并与该位对比，若不一致则将对应的帧丢弃

### 内部帧结构定义

一个RovLink内部帧包含8个字节的数据，这使得它能够通过CAN总线进行传输。

| 数据类型 | 特征指示                    | 数据    |
| -------- | --------------------------- | ------- |
| Opcode   | Ibits-DLC-Vbit-Sbit（IDVS） | Payload |

内部帧是标准帧的简化版，仅仅去除了帧头和帧尾。因为不包含帧头，传输内部帧需要物理层硬件层面的起始帧支持；抑或是要求设备降低传输速率，避免出现数据覆盖的情况，这将交由用户/开发者自行决定

### 消息种类对照表 Opcode LUT

可供使用的预定义的Opcode如附录Excel中表格所示

表格的每行代表高四位的值，每列代表第四位的值，二者相与（AND）即可得到Opcode的对应值

## RovLink路由

在水下机器人中，我们常常需要用到较多MCU或SoC互联，因此需要指令能够从上位机准确发送到目标SoC；同样，需要回报的传感器数据从下位机以稳定的频率回传到上位机；很多时候也需要下位机内部的智能控制设备暂时替代上位机向目标MCU发送控制指令和接收来自其他设备的传感器数据。RovLink的路由功能可以满足该需求

支持RovLink的每个设备都需要定义自己的ID，这被称为设备ID（Device ID，**DID**）；同时需要定义自己需要接收（Peek）的数据的Opcode，这些Opcode组合成截留数据类型列表（Opcode Peek List，**OPL**）；还需要定义自己允许接收数据的来源，也就是允许的源设备ID，这被称为白名单（White List，**WL**）

### 源设备

当设备A向其他设备发送RovLink帧时，设备A就被称为这一帧的**源设备**（Source Device，**SD**），*其DID需要被写入帧的Ibits段*

### 目标设备

需要使用到来自某个源设备的RovLink帧的设备被称为**目标设备**（Destination Device，**DD**），目标设备会按照预先定义的OPL和WL来接收和译码来自指定源设备的指定类型帧数据

### 中间设备

源设备的RovLink帧以一对一总线的形式发出，如果与源设备相连的设备并不是目标设备，那么这个设备就成为**中间设备**（Route Device，**RD**）。

RD会根据自己预先定义的OPL和WL来接收帧数据，但对于非WL的其他所有设备发来的帧，都会执行**路由**（Route），也就是在不解包出Payload的情况下将帧数据发送到更接近目标设备的总线上。

有些数据需要被多个RD接收和处理，这些数据需要被预先定义在这些RD的OPL和WL中，RD在接收到数据后继续执行路由转发

需要指出：*在使用互联总线（如CAN）的时候，不存在中间设备，来自SD的帧能够直接发送到DD*

### 一些设备规定

* 上位机是源设备，同时也是目标设备
* 当且仅当上位机作为转发服务器（CoralReef Server Mode）时，允许作为中间设备
* 负责控制推进器的MCU或SoC不允许作为中间设备，但可作为源设备和目标设备

## RovLink特性

RovLink支持水下机器人最常使用的几种数据传输，具有特定功能的RovLink帧如下所示

### 指令帧

指令帧是Payload中包含了控制指令的帧

### 回传帧

回传帧是Payload中包含了传感器回传数据的帧

### 状态帧

状态帧是Payload中包含了机器人当前状态回传数据的帧

### 心跳包

心跳包是一种特殊的帧，上位机和下位机之间必须以“握手”的形式以恒定间隔互相发送心跳包。**如果下位机超过5s没有接收到上位机发送的心跳包，必须将机器人置为休眠状态。**

规定心跳包必须由上位机先向下位机发送，Payload包含了uint32_t格式的UNIX时间戳，并且要求发送间隔小于1s；下位机接收到心跳包后，立即向上位机返回一帧心跳包，发送的心跳包内容可以随意，但推荐为当前的RTOS时间或者Systick时间，并格式化为uint32_t

**休眠状态**下，要求机器人推进器停转或保持低速上浮、所有舵机复位到默认状态，机械手或机械臂保持原状，其他对环境无干扰的外设全部关闭，灯光置为闪烁状态，便于后续搜救打捞团队能够快速定位机器人

如果机器人主控开启了黑匣子，在进入休眠状态后应当锁定存储设备写入并等待

### 功能帧

功能帧是用于RovLink自身功能触发的特殊帧

突发传输需要使用功能帧实现传输开始、停止和重连

允许功能帧中包含32位指针来在软件系统内通过RovLink传递复杂数据包，从而兼容其他协议

## RovLink突发传输

RovLink是定长的协议，但允许通过**突发传输**（**Burst Transaction**）的方式传输较长的数据

### 突发传输形式

由于RovLink的每一帧都限制最多携带6个字节的数据（Payload），更长的数据只能通过多帧传输。在开启突发传输后，源设备向总线连续发送数个功能帧形式的RovLink帧，每一帧中都携带了6个字节的数据，直到将待发送的所有数据传输完毕。

突发传输总是以一个功能帧形式的RovLink帧作为开始标志，称为**起始帧**。目标设备在接收到起始帧后，需要等待后续功能帧。所有数据传输结束后，源设备需要发送一个功能帧形式的RovLink帧作为结束标志，称为**结束帧**，目标设备在接收到结束帧后，可以处理接收到的数据。

在源设备发送起始帧后，应当保留至少500ms的空闲时间，在该区间内，目标设备需要完成对设备的调整以应对突发传输中的大带宽需求

突发传输中，握手协议被作为一个可选项，允许开发者自行设置。目标设备在接收到每一帧后都可以通过帧尾的校验位对帧数据进行检验，并向源设备发送一个空白的**确认帧**。如果源设备在发送完一帧数据后没有接收到确认帧，需要重发该帧

### 突发控制

突发传输的控制完全由源设备决定，目标设备需要实现一个状态机，根据源设备发送的控制指令来改变状态。

允许的突发传输状态有：

* *空闲*（IDLE）：不进行突发传输的状态
* *忙*（BUSY）：正在接收突发数据的状态
* *中断*（INT）：收到重连或暂停突发传输指令的状态
* *等待*（WAIT）：等待源设备发送突发数据的状态

## RovLink示例

RovLink提供3个基础示例：

* **RovLinkHost**：基于Python的游戏手柄摇杆控制RovLink设备脚本（一个只能进行设备运动控制的上位机）
* **RovLinkDecoder**：基于Python的RovLink协议编解码和串口调试工具
* **Rpdater**：基于Python的RovLink协议OTA烧录工具

这三个示例均位于*FinNAV根目录下Tools子目录*