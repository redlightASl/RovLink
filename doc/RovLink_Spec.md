# 协议定义 Protocol Defination

> [!NOTE]
>
> 本文档介绍了RovLink的消息帧结构、路由方式、通讯方式定义。

RovLink本质上是一种消息结构，可以建立在不同总线/传输协议物理层上。RovLink主要针对水下机器人的上位机（CoralReef-X）和下位机（FinNAV based ROV/AUV/UUV）通讯场景设计。

为了方便不同性能的设备使用，RovLink采用了**定长**帧结构，并设计了两种基本帧格式，保障协议可以在串行板级总线或并行片上总线物理层上完成传输。

针对本文档中的内容，读者可以自行参考附录 `isa` 中的 `Excel` 表格

## RovLink帧结构

一条RovLink消息被称为**RovLink帧**（**Frame**）

RovLink帧可以分成两种：

* **标准帧** `StandardDataFrame`：**上位机和机器人主控之间必须使用标准帧传输**，机器人内部可以选择传输标准帧或内部帧
* **内部帧** `InnerDataFrame`：**机器人内部使用CAN总线或片上总线物理层互联时，只能使用内部帧**

特别地，RovLink支持以**突发传输**（**Burst Transmission**）的方式传输更大规模数据。

### 标准帧结构定义

一个RovLink标准帧包含**10个字节**数据。

| 帧头起始位 | 数据类型 | 特征指示                    | 数据    | 帧尾校验位 |
| ---------- | -------- | --------------------------- | ------- | ---------- |
| FrameHead  | Opcode   | Ibits-DLC-Vbit-Sbit（IDVS） | Payload | Check      |

帧头**FrameHead**恒为一个字节（8 bit）的起始位 `0xFD`

数据类型**Opcode**由一个对照表指定，对照表中每个不同的值代表一个不同的数据类型，本段也是8位。Opcode高四位表明本帧对应的*指令子集*，低四位决定本帧的*具体数据类型*。更多信息可以参考[ISA说明](./RovLink_ISA.md) 

> [!IMPORTANT]
>
> **Opcode决定了一个帧数据的语义信息，但如何解算出语义则要根据特征指示码中的DLC来判断**

特征指示**IDVS**由四个不同的段构成，如下表所示

| 设备ID            | 数据长度码              | 检验有效位    | 传感器有效位   |
| ----------------- | ----------------------- | ------------- | -------------- |
| Identify（Ibits） | Data Length Code（DLC） | Valid（Vbit） | Sensor（Sbit） |

**设备ID**（Identify），简写为**Ibits**或**ID**，用来指示发送本帧的*源设备*（Source Device）。*中间设备*（Route Device）根据本段进行数据路由。Ibits长度为4位（4 bits），可供使用的路由地址从0x0到0xF共16个，RovLink可以提供15个设备的路由

**数据长度码**（Data Length Code），简写为**DLC**，用来指示本帧数据应当如何解算，根据不同取值可分为如下四种情况：

* `2'b00`：多个数据，后续的数据Payload部分存储6个uint8_t格式的数据

    > 常用于上位机控制下位机进行模式切换，或控制一些以开关量（0/1）描述的外设，也可用于上传较多具有小数值的传感器数据
    >
    > 在用户扩展指令子集中，DLC=2'b00情况下，允许用户使用后续6*8=48bit传输更多开关量

* `2'b01`：大数或突发模式，后续的数据Payload部分存储1个uint32_t格式的数据；或存储了1个uint48_t格式的数据；或存储突发模式标志用来控制RovLink突发传输

    > 常用于突发传输的控制，详见后续RovLink突发传输部分；也用于某些特殊大数据的传输

* `2'b10`：2个数据，后续的数据Payload部分存储1个uint32_t格式的数据和一个uint16_t格式的数据

    > 常用于对下位机某些算法关键参数的修改，uint32_t格式数据常常以32位浮点数（fp32）格式读取，uint16_t则用于指定要修改算法的哪一个参数（算法对象标志位）。特别地，[*RovLink心跳包*](###心跳包)采用这种DLC

* `2'b11`：3个数据，后续的数据Payload部分存储3个uint16_t格式的数据

    > 常用于一般的外设控制和传感器数据上传

> [!IMPORTANT]
>
> **一帧数据的Payload的解析方式由且仅由DLC决定。**

> RovLink通过DLC控制Payload解码的方式来扩展一个Opcode的兼容性：具有相同Opcode的帧根据DLC不同可以衍生出4种解析方法，从而让相同Opcode的帧能够承载语义相同但数量不同的数据

**检验有效位**（Valid），简写为**Vbit**，长度为一个位（1 bit），用来控制本帧是否使用帧尾校验位。如果该位为1'b0，那么帧尾校验位会被忽略；如果该位为1'b1，那么需要使用程序预设的校验算法对数据Payload部分进行校验，并与帧尾校验位进行对比，如果不一致则舍弃该帧数据

**传感器有效位**（Sensor），简写为**Sbit**，长度为一个位（1 bit）。在用于传输传感器数据的*回传帧中*，该位表示当前传感器的工作状态，用户程序可以自行选择是否相信本帧数据。在*功能帧*中，该位用于说明本帧是否具有后继帧，如果该位是1，表示本帧具有后续数据，是一个起始帧或一个单纯用于传输数据的功能帧，如果该位为0，表示本帧后没有后续数据，是一个结束帧。在其他功能帧中，该位保留，用户被允许自行定义该位的用途

> 有关功能帧的描述见[RovLink特性](##RovLink特性)

数据包**Payload**包含6个字节（6 Bytes），用于搭载帧要传递的数据或指令。这些数据使用下面的几种数据格式被保存到帧中：

* *uint8_t*：数据被以8位无符号整型的方式存储
* *uint16_t*：数据被以16位无符号整型的方式存储
* *uint32_t*：数据被以32位无符号整型的方式存储
* *uint48_t*：数据被以48位无符号整型的方式存储

一般地，float_t格式（fp32）的数据直接保存到帧中进行传输，读取时再以float_t的形式进行读取，从而保证传输中的无精度损失；uint64_t或int64_t的数据会被量化到符合uint48_t或int48_t的数据大小后再以uint48_t的数据格式保存到帧中传输，存在量化误差

> 在读写单精度浮点数时，程序应当遵循IEEE754规范，或交给编译器自动处理

**Payload以大端格式存储**，待发送数据的高字节存储在`Payload[0]`处

RovLink**不支持**double_t格式（fp64）的数据传输

> [!TIP]
>
> 允许使用自定义的突发传输来逐帧传递48位以上长度的数据

帧尾**Check**是一个字节大小的校验位。如果IDVS中Vbit=0，那么该位在传输过程中可以被忽略；如果IDVS中Vbit=1，该位指定了以某一校验算法对Payload段进行校验计算后的输出值，每一个中间设备都需要进行一次校验并与该位对比，若不一致则将对应的帧丢弃

### 内部帧结构定义

一个RovLink内部帧包含8个字节的数据，这使得它能够通过CAN总线进行传输。

| 数据类型 | 特征指示                    | 数据    |
| -------- | --------------------------- | ------- |
| Opcode   | Ibits-DLC-Vbit-Sbit（IDVS） | Payload |

内部帧是标准帧的简化版，去除帧头和帧尾。因为不包含帧头，传输内部帧需要物理层/传输层的起始帧检测支持；抑或是要求设备降低传输速率，避免出现数据覆盖的情况，这将交由开发者自行决定

内部帧的其他内容和标准帧完全一致

### 压缩指令帧

用户可参考[RovLink压缩指令帧规范文档](./RovLink_Compress.md)获取更多信息

### 消息种类对照表 Opcode LUT

可供使用的预定义的Opcode查找表如附录 `isa` 中的 `Excel` 表格；也可以参考RovLink的[ISA规范文档](./RovLink_ISA.md)

表格的每行代表高四位指令子集的值，每列代表低四位具体数据类型的值，二者相或（OR）即可得到Opcode的对应值

## RovLink广播

在水下机器人中，我们常常需要较多SoC板间互联，因此要求指令能从上位机准确发送到目标SoC；同样，需要回报的传感器数据从下位机以稳定的频率回传给上位机；很多时候也需要下位机内部的智能控制设备暂时替代上位机向目标MCU发送控制指令和接收来自其他设备的传感器数据。RovLink基于路由功能满足该需求。

支持RovLink的每个设备都需要定义自己的ID，这被称为**设备ID**（Device ID，**DID**）；同时需要定义自己需要接收（Peek）数据的Opcode，这些Opcode组合成**截留数据类型列表**（Opcode Peek List，**OPL**）；还需要定义自己允许接收数据的来源，也就是允许的源设备ID，这被称为**白名单**（White List，**WL**）

下面给出一些基本定义

### 源设备

当设备A向其他设备发送RovLink帧时，设备A就被称为这一帧的**源设备**（Source Device，**SD**），*其DID需要被写入帧的Ibits段*

### 目标设备

需要使用到来自某个源设备的RovLink帧的设备被称为**目标设备**（Destination Device，**DD**），目标设备按照预先定义的OPL和WL接收来自指定源设备的指定类型帧数据

### 中间设备

如果源设备的RovLink帧以一对一总线的形式发出，且与源设备相连的设备并不是目标设备，那么这个设备就称为**中间设备**（Route Device，**RD**）。

RD会根据自己预先定义的OPL和WL来接收帧数据，但对于非WL的其他所有设备发来的帧，都会执行**路由**（Route），在不解包出Payload的情况下将帧数据发送到更接近目标设备的总线上。

有些数据需要被多个RD接收和处理，这些数据需要被预定义在这些RD的OPL和WL中，RD在接收到数据后继续执行路由转发

需要指出：*在使用互联总线（如CAN）的时候，不存在中间设备，来自SD的帧能够直接发送到DD*，这种情况下，使用内部帧不需要支持RovLink路由

### 一些规定

* 上位机是源设备，同时也是目标设备
* 当且仅当上位机作为转发服务器（CoralReef Server Mode）时，允许作为中间设备
* 负责控制推进器的MCU或SoC不允许作为中间设备，但可作为源设备和目标设备

## RovLink帧特性

RovLink支持水下机器人最常使用的几种数据传输，包括控制指令、传感器回传数据、机器人当前状态、心跳包、特殊功能帧。这些类型的数据不会被帧中任何一位数据指定，**仅取决于Opcode所说明的数据类型**。具有特定功能的RovLink帧如下所示

### 指令帧

指令帧是Payload中包含了控制指令的帧。控制台通过向机器人发送一条指令帧来让机器人完成某项工作或达到某种状态

### 回传帧

回传帧是Payload中包含了传感器回传数据的帧。机器人会按照固定的频率向控制台发送已定义的回传帧

### 状态帧

状态帧是Payload中包含了机器人当前状态回传数据的帧。状态帧与回传帧不同的地方在于：只有当控制台（帧DID为 `0x05` 的情况）向机器人发送一条空白状态帧时，机器人才能够向控制台（源设备）返回一条Opcode相同且包含状态数据Payload的状态帧

### 心跳包

心跳包是一种特殊的帧，上位机和下位机之间必须以“握手”形式以恒定间隔互相发送心跳包。**如果下位机超过5s没有接收到上位机发送的心跳包，视为心跳包超时，应当将机器人置为休眠状态。**

规定**心跳包必须由上位机先向下位机发送**，Payload包含uint32_t格式的UNIX时间戳，要求发送间隔小于1s；下位机接收到心跳包后，立即向上位机返回一帧心跳包，不对回传心跳包的Payload作要求，但推荐设置为当前的UNIX时间戳或RTOS系统时钟截取低32位，统一格式化为uint32_t

**休眠状态**下，要求机器人推进器停转或保持低速上浮、机器人外部动作停止，所有舵机复位到默认状态，机械手或机械臂保持上次接收到心跳包时刻之前的状态，其他对环境存在干扰的外设全部关闭，灯光置为高亮或闪烁状态，便于搜救打捞团队能够快速定位机器人，防止机器人对外界人员或环境造成伤害。如果机器人开启黑匣子功能，休眠后应当优先将设备传感器数据记录到存储设备。

### 功能帧

功能帧是用于RovLink自身功能触发的特殊帧

突发传输需要使用功能帧实现传输开始、停止和重连

允许功能帧中包含32位指针来在软件系统内通过RovLink传递复杂数据包，从而兼容其他协议或切换到厂测模式

## RovLink突发传输

RovLink是定长的协议，但允许通过**突发传输**（**Burst Transaction**）的方式传输较长的数据

### 突发传输形式

由于RovLink的每一帧都限制最多携带6个字节的数据（Payload），更长的数据只能通过多帧传输。在开启突发传输后，源设备向总线连续发送数个功能帧形式的RovLink帧，每一帧中都携带了6个字节的数据，直到将待发送的所有数据传输完毕。

突发传输过程中所有帧都使用功能帧形式，采取标准帧IDVS部分的Sbit作为起始和结束的标志：突发传输总是以一个Sbit=1的RovLink帧作为开始标志，称为**起始帧**。目标设备在接收到起始帧后，需要等待后续功能帧，这些承载数据的功能帧都具有Sbit=1的特征。数据传输末尾，最后一个数据包的Sbit=0作为结束标志，该帧称为**结束帧**，目标设备在接收到结束帧后处理接收到的数据。

突发传输采用**大端**格式，按6字节对齐，待传输数据的高6字节会被首先传送（与Payload采用大端一致）

在源设备发送起始帧后，应当保留至少50ms的空闲时间，该区间内，目标设备需要完成对设备的调整以应对突发传输中的连续接收和可能的握手需求

由于RovLink采用6字节对齐，很可能出现末尾字节无法正好填充满整个帧的情况，要求*在空白字节填充0xFF*。比如传输28个字节，通过4帧传输完高24字节后，还剩余末尾4字节需要传输，这时将末尾4字节填充到Payload部分的[0]~[3]字节，第[4]和[5]字节填充为0xFF

突发传输的整体步骤如下：

* 源设备向目标设备发送起始帧 
* 源设备等待20ms，目标设备切换工作状态
* 源设备向目标设备连续发送数帧突发传输数据帧
* 源设备向目标设备发送结束帧
* 目标设备对数据进行后处理

### 握手协议

突发传输中，*握手协议*被作为一个可选项，允许开发者自行设置。目标设备在接收到每一帧后都可以通过帧尾的校验位对帧数据进行检验，并向源设备发送一个带有当前帧数目的**确认帧**。如果源设备在发送完一帧数据后没有接收到确认帧，或确认帧内标记的当前帧数目与源设备已发送的数据帧数目存在偏差，则需要重发该帧

带有握手协议的突发传输的整体步骤如下：

* 源设备向目标设备发送起始帧 
* 源设备等待20ms，目标设备切换工作状态
* 源设备向目标设备连续发送突发传输数据帧
* 目标设备向源设备发送确认帧
* 重复上述两步，如果源设备对确认帧校验失败，则重新发送上一突发传输数据帧
* 源设备向目标设备发送结束帧
* 目标设备对数据进行后处理

### 传输中断

突发传输中，*传输中断*被作为一个可选项，允许开发者自行设置。源设备通过向目标设备发送一个**中断帧**来打断当前突发传输过程，切换到正常的RovLink传输。

中断帧后应保留至少50ms的空闲时间，随后源设备和目标设备通信应当恢复正常RovLink传输。协议对中断过程中设备运行状态不做规定，只要求目标设备必须能够保障在中断后可以及时恢复正常的RovLink传输

源设备通过向目标设备发送一个**中断恢复帧**来继续被中断的突发传输，中断恢复帧后应保留至少50ms的空闲时间

### 突发控制

**突发传输的控制完全由源设备决定**，目标设备需要根据源设备发送的控制指令来改变状态。

允许的突发传输状态有：

* *空闲*（IDLE）：不进行突发传输的状态
* *忙*（BUSY）：正在接收突发数据的状态
* *中断*（INT）：收到重连或暂停突发传输指令的状态
* *等待*（WAIT）：等待源设备发送突发数据的状态

## RovLink示例

RovLink提供3个基础示例：

* **RovLinkHost**：基于Python的游戏手柄摇杆控制RovLink设备脚本（一个只能进行设备运动控制的上位机）
* **RovLinkDecoder**：基于Python的RovLink协议编解码和串口调试工具
* **Rpdater**：基于Python的RovLink协议OTA烧录工具

这三个示例均位于 `tools` 目录